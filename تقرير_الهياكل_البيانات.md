# تقرير الهياكل البيانات - المجموعة الأولى

**إعداد:** جهاد المنبهي  
**المجموعة:** الأولى  
**التخصص:** ذكاء أعمال  
**المادة:** الهياكل البيانات  
**التاريخ:** 2026

---

## المقدمة

يقدم هذا التقرير شرحاً مفصلاً للهياكل البيانات الأساسية في لغة Java مع المقارنات الاحترافية والأمثلة العملية.

---

## 1. المصفوفات (Arrays)

### نظرة عامة
المصفوفات هي أبسط هياكل البيانات في Java، وتسمح بتخزين مجموعة من العناصر من نفس النوع.

### المميزات
- وصول سريع للعناصر (O(1))
- ذاكرة متجاورة
- حجم ثابت

### العيوب
- حجم ثابت لا يمكن تغييره
- إضافة/حذف العناصر يتطلب إنشاء مصفوفة جديدة

```java
// تعريف مصفوفة من الأعداد الصحيحة
int[] numbers = new int[5];
numbers[0] = 10; // الوصول للعنصر الأول
numbers[1] = 20; // الوصول للعنصر الثاني

// مصفوفة محددة بالقيم
String[] names = {"أحمد", "محمد", "فهد"};
```

---

## 2. القوائم المرتبطة (Linked Lists)

### نظرة عامة
القائمة المرتبطة هي هيكل بيانات ديناميكي يتكون من عقد متصلة ببعضها البعض.

### المميزات
- حجم ديناميكي
- إضافة وحذف سريع (O(1))
- لا تضيع ذاكرة

### العيوب
- الوصول للعناصر بطيء (O(n))
- ذاكرة إضافية للروابط

```java
// إنشاء قائمة مرتبطة في Java
LinkedList<String> linkedList = new LinkedList<>();
linkedList.add("العنصر الأول");
linkedList.add("العنصر الثاني");
linkedList.addFirst("العنصر في البداية");
linkedList.addLast("العنصر في النهاية");
```

---

## 3. المكدسات (Stacks)

### نظرة عامة
المكدس يتبع مبدأ LIFO (Last In First Out) - آخر عنصر يدخل هو أول عنصر يخرج.

### التطبيقات
- التراجع في المحررات
- حساب التعبيرات الرياضية
- استدعاء الدوال

```java
// استخدام المكدس في Java
Stack<Integer> stack = new Stack<>();
stack.push(10);  // إضافة عنصر
stack.push(20);
stack.push(30);

int top = stack.pop();  // إزالة العنصر العلوي (30)
int peek = stack.peek(); // النظر للعنصر العلوي بدون إزالته (20)
```

---

## 4. الطوابير (Queues)

### نظرة عامة
الطابور يتبع مبدأ FIFO (First In First Out) - أول عنصر يدخل هو أول عنصر يخرج.

### التطبيقات
- أنظمة التذاكر
- معالجة المهام
- طباعة المستندات

```java
// استخدام الطابور في Java
Queue<String> queue = new LinkedList<>();
queue.add("العميل الأول");
queue.add("العميل الثاني");
queue.add("العميل الثالث");

String first = queue.remove(); // إزالة العنصر الأول
String peek = queue.peek();    // النظر للعنصر الأول
```

---

## 5. الأشجار (Trees)

### نظرة عامة
الأشجار هي هياكل بيانات هرمية تتكون من عقد متصلة ببعضها البعض.

### أنواع الأشجار

#### الشجرة الثنائية (Binary Tree)
```java
class TreeNode {
    int value;
    TreeNode left;
    TreeNode right;
    
    TreeNode(int value) {
        this.value = value;
        this.left = null;
        this.right = null;
    }
}
```

#### شجرة البحث الثنائية (Binary Search Tree)
```java
class BST {
    TreeNode root;
    
    // إضافة عنصر للشجرة
    void insert(int value) {
        root = insertRecursive(root, value);
    }
    
    private TreeNode insertRecursive(TreeNode current, int value) {
        if (current == null) {
            return new TreeNode(value);
        }
        
        if (value < current.value) {
            current.left = insertRecursive(current.left, value);
        } else if (value > current.value) {
            current.right = insertRecursive(current.right, value);
        }
        
        return current;
    }
}
```

---

## 6. جداول التجزئة (Hash Tables)

### نظرة عامة
جداول التجزئة تستخدم دالة التجزئة لتخزين البيانات بكفاءة عالية.

### المميزات
- بحث سريع جداً (O(1) في المتوسط)
- إضافة وحذف سريع
- استخدام فعال للذاكرة

```java
// استخدام HashMap في Java
HashMap<String, Integer> hashMap = new HashMap<>();
hashMap.put("أحمد", 25);
hashMap.put("محمد", 30);
hashMap.put("فهد", 28);

int age = hashMap.get("أحمد"); // الحصول على القيمة
boolean exists = hashMap.containsKey("محمد"); // التحقق من وجود المفتاح
```

---

## 7. المقارنات الاحترافية بين الهياكل

### مقارنة الأداء

| الهيكل | البحث | الإضافة | الحذف | الوصول |
|--------|-------|---------|-------|--------|
| مصفوفة | O(n) | O(n) | O(n) | O(1) |
| قائمة مرتبطة | O(n) | O(1) | O(1) | O(n) |
| شجرة بحث ثنائية | O(log n) | O(log n) | O(log n) | O(log n) |
| جدول تجزئة | O(1) | O(1) | O(1) | O(1) |

### متى نستخدم كل هيكل؟

#### المصفوفات
- عندما يكون حجم البيانات معروف مسبقاً
- عندما نحتاج وصول سريع للعناصر بالفهرس
- عندما تكون الذاكرة محدودة

#### القوائم المرتبطة
- عندما نحتاج إضافة وحذف متكرر
- عندما يكون حجم البيانات متغير
- عندما لا نحتاج وصول عشوائي سريع

#### المكدسات
- عندما نحتاج مبدأ LIFO
- في تطبيقات التراجع
- في معالجة التعبيرات الرياضية

#### الطوابير
- عندما نحتاج مبدأ FIFO
- في أنظمة الانتظار
- في معالجة المهام بالترتيب

#### الأشجار
- عندما نحتاج بحث سريع مع الحفظ على الترتيب
- في تمثيل البيانات الهرمية
- في تطبيقات الملفات والمجلدات

#### جداول التجزئة
- عندما نحتاج بحث سريع جداً
- في تطبيقات الخرائط والقواميس
- في التخزين المؤقت

---

## 8. أمثلة عملية متقدمة

### مثال 1: نظام إدارة الطلاب
```java
class StudentManagementSystem {
    private HashMap<String, Student> studentsById;
    private LinkedList<Student> waitingList;
    private Stack<Student> recentStudents;
    
    public StudentManagementSystem() {
        studentsById = new HashMap<>();
        waitingList = new LinkedList<>();
        recentStudents = new Stack<>();
    }
    
    // إضافة طالب جديد
    public void addStudent(Student student) {
        studentsById.put(student.getId(), student);
        recentStudents.push(student);
    }
    
    // البحث عن طالب
    public Student findStudent(String id) {
        return studentsById.get(id);
    }
    
    // إضافة طالب لقائمة الانتظار
    public void addToWaitingList(Student student) {
        waitingList.add(student);
    }
}
```

### مثال 2: نظام الملفات الهرمي
```java
class FileSystem {
    private FileNode root;
    
    class FileNode {
        String name;
        boolean isDirectory;
        List<FileNode> children;
        
        FileNode(String name, boolean isDirectory) {
            this.name = name;
            this.isDirectory = isDirectory;
            this.children = new ArrayList<>();
        }
    }
    
    // إنشاء هيكل الملفات
    public void createFileSystem() {
        root = new FileNode("root", true);
        
        FileNode documents = new FileNode("Documents", true);
        FileNode pictures = new FileNode("Pictures", true);
        
        documents.children.add(new FileNode("report.pdf", false));
        documents.children.add(new FileNode("presentation.pptx", false));
        
        pictures.children.add(new FileNode("vacation.jpg", false));
        pictures.children.add(new FileNode("family.png", false));
        
        root.children.add(documents);
        root.children.add(pictures);
    }
}
```

---

## 9. الخلاصة والتوصيات

### الخلاصة
- كل هيكل بيانات له استخداماته المثلى
- الاختيار الصحيح يعتمد على متطلبات التطبيق
- الأداء يختلف بشكل كبير بين الهياكل المختلفة

### التوصيات
1. **للبحث السريع:** استخدم جداول التجزئة أو أشجار البحث
2. **للإضافة والحذف المتكرر:** استخدم القوائم المرتبطة
3. **للوصول العشوائي السريع:** استخدم المصفوفات
4. **للبيانات الهرمية:** استخدم الأشجار
5. **لمبدأ LIFO/FIFO:** استخدم المكدسات والطوابير

---

## 10. المراجع

- "Data Structures and Algorithms in Java" by Robert Lafore
- "Introduction to Algorithms" by Cormen et al.
- Java Documentation - Oracle
- GeeksforGeeks - Data Structures

---

**تقرير من إعداد:** جهاد المنبهي  
**المجموعة الأولى - ذكاء أعمال**  
**جامعة العلوم والتكنولوجيا**  
**عام 2026**
